name: CD — Deploy to Kubernetes

# Triggers on push to main/master (staging auto-deploy).
# Production requires manual approval via GitHub Environment protection rules.
on:
  push:
    branches:
      - main
      - master
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        type: choice
        options:
          - staging
          - production
        default: staging
      force_production:
        description: 'Skip staging gate and deploy directly to production (emergency only)'
        required: false
        type: boolean
        default: false
      rollback_revision:
        description: 'Helm revision number to roll back to (rollback job only — leave blank for auto)'
        required: false
        type: string
        default: ''

# Prevent concurrent deployments to the same environment.
# A staging deploy must finish before another starts; same for production.
concurrency:
  group: cd-${{ github.ref }}-${{ github.event.inputs.environment || 'staging' }}
  cancel-in-progress: false

env:
  REGISTRY: ghcr.io
  IMAGE_PREFIX: ${{ github.repository_owner }}/edusphere
  HELM_CHART_PATH: ./infrastructure/k8s/helm/edusphere
  KUBECTL_VERSION: 'v1.29.0'
  HELM_VERSION: 'v3.14.0'

# ─────────────────────────────────────────────────────────────────────────────
# JOB 0 — Build and push Docker images to GHCR
# Runs before any deployment job; downstream jobs consume the image tag output.
# ─────────────────────────────────────────────────────────────────────────────
jobs:
  build-and-push:
    name: Build & Push — ${{ matrix.service }}
    runs-on: ubuntu-latest
    timeout-minutes: 30
    permissions:
      contents: read
      packages: write
      security-events: write

    strategy:
      fail-fast: false
      matrix:
        service:
          - gateway
          - subgraph-core
          - subgraph-content
          - subgraph-annotation
          - subgraph-collaboration
          - subgraph-agent
          - subgraph-knowledge
          - web

    outputs:
      # The image tag is the same across all matrix legs; expose from one key.
      # Downstream jobs reference build-and-push.outputs.image_tag via the
      # needs map — GitHub resolves the value from the first completed leg.
      image_tag: ${{ steps.meta.outputs.version }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # ── GHCR authentication ─────────────────────────────────────────────────
      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # ── Derive deterministic image tags ────────────────────────────────────
      # Primary tag: <branch>-<short-sha>  (e.g. main-a1b2c3d)
      # Also tags 'latest' for pushes to main/master.
      - name: Extract Docker metadata (tags, labels)
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}-${{ matrix.service }}
          tags: |
            type=sha,prefix=main-,format=short
            type=raw,value=latest,enable=${{ github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master' }}
            type=semver,pattern={{version}}
          labels: |
            org.opencontainers.image.title=EduSphere ${{ matrix.service }}
            org.opencontainers.image.description=EduSphere AI Knowledge Graph Platform — ${{ matrix.service }}
            org.opencontainers.image.vendor=EduSphere
            org.opencontainers.image.source=https://github.com/${{ github.repository }}
            org.opencontainers.image.revision=${{ github.sha }}

      # ── Build and push ──────────────────────────────────────────────────────
      - name: Build and push Docker image — ${{ matrix.service }}
        id: build-push
        uses: docker/build-push-action@v5
        with:
          context: .
          file: apps/${{ matrix.service }}/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            NODE_VERSION=20
            PNPM_VERSION=9
            BUILD_DATE=${{ github.event.head_commit.timestamp }}
            VCS_REF=${{ github.sha }}
            VERSION=${{ steps.meta.outputs.version }}
          provenance: false

      # ── Trivy security scan — block on HIGH/CRITICAL before deploy ─────────
      # Scan the freshly pushed image by digest so we get the exact artifact.
      - name: Trivy scan — ${{ matrix.service }} (HIGH/CRITICAL → fail)
        uses: aquasecurity/trivy-action@0.28.0
        with:
          image-ref: ${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}-${{ matrix.service }}@${{ steps.build-push.outputs.digest }}
          format: sarif
          output: trivy-${{ matrix.service }}.sarif
          severity: HIGH,CRITICAL
          exit-code: '1'
          ignore-unfixed: true
          vuln-type: os,library

      - name: Upload Trivy SARIF to GitHub Security
        if: always()
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: trivy-${{ matrix.service }}.sarif
          category: trivy-cd-${{ matrix.service }}

  # ─────────────────────────────────────────────────────────────────────────
  # Pre-flight check: verify deployment secrets/variables are configured.
  # ─────────────────────────────────────────────────────────────────────────
  check-prerequisites:
    name: Check Deployment Prerequisites
    runs-on: ubuntu-latest
    needs: build-and-push
    outputs:
      can_deploy: ${{ steps.check.outputs.can_deploy }}
      image_tag: ${{ steps.derive-tag.outputs.IMAGE_TAG }}
    steps:
      - name: Check if deployment is enabled
        id: check
        run: |
          if [[ "${{ vars.DEPLOYMENT_ENABLED }}" == "true" ]]; then
            echo "can_deploy=true" >> $GITHUB_OUTPUT
            echo "Deployment prerequisites met — proceeding with K8s deployment"
          else
            echo "can_deploy=false" >> $GITHUB_OUTPUT
            echo "::notice::Deployment skipped. Set repository variable DEPLOYMENT_ENABLED=true and add KUBECONFIG_STAGING/KUBECONFIG_PRODUCTION secrets to enable."
          fi

      - name: Derive canonical image tag
        id: derive-tag
        run: |
          SHORT_SHA="${GITHUB_SHA::7}"
          IMAGE_TAG="main-${SHORT_SHA}"
          echo "IMAGE_TAG=${IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "Canonical image tag: ${IMAGE_TAG}"

  # ─────────────────────────────────────────────────────────────────────────
  # JOB 1 — Deploy to Staging (automatic on every push to main/master)
  # ─────────────────────────────────────────────────────────────────────────
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    timeout-minutes: 25
    environment:
      name: staging
      url: https://staging-api.edusphere.dev/graphql
    needs: [check-prerequisites]
    # Auto-deploy on push; allow manual re-deploy targeting staging.
    if: |
      needs.check-prerequisites.outputs.can_deploy == 'true' &&
      (github.event_name == 'push' ||
       github.event.inputs.environment == 'staging')

    outputs:
      image_tag: ${{ steps.image-tag.outputs.IMAGE_TAG }}
      deploy_time: ${{ steps.image-tag.outputs.DEPLOY_TIME }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # ── Tooling setup ──────────────────────────────────────────────────────
      - name: Set up kubectl ${{ env.KUBECTL_VERSION }}
        uses: azure/setup-kubectl@v4
        with:
          version: ${{ env.KUBECTL_VERSION }}

      - name: Set up Helm ${{ env.HELM_VERSION }}
        uses: azure/setup-helm@v4
        with:
          version: ${{ env.HELM_VERSION }}

      # ── Cluster authentication ─────────────────────────────────────────────
      - name: Configure kubectl for staging cluster
        run: |
          mkdir -p ~/.kube
          echo "${{ secrets.KUBECONFIG_STAGING }}" | base64 -d > ~/.kube/config
          chmod 600 ~/.kube/config
          kubectl config use-context staging

      - name: Verify staging cluster connection
        run: |
          echo "Cluster info:"
          kubectl cluster-info
          echo ""
          echo "Node status:"
          kubectl get nodes -o wide

      # ── Derive image tag ───────────────────────────────────────────────────
      - name: Derive image tag and deploy metadata
        id: image-tag
        run: |
          SHORT_SHA="${GITHUB_SHA::7}"
          IMAGE_TAG="main-${SHORT_SHA}"
          DEPLOY_TIME="$(date -u +'%Y-%m-%dT%H:%M:%SZ')"
          echo "IMAGE_TAG=${IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "DEPLOY_TIME=${DEPLOY_TIME}" >> $GITHUB_OUTPUT
          echo "Deploying image tag: ${IMAGE_TAG}"
          echo "Deploy time: ${DEPLOY_TIME}"

      # ── Log in to GHCR (Helm may need to pull OCI charts) ─────────────────
      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # ── Helm upgrade — staging ─────────────────────────────────────────────
      - name: Helm upgrade — staging
        id: helm-staging
        run: |
          helm upgrade --install edusphere-staging ${{ env.HELM_CHART_PATH }} \
            --namespace edusphere-staging \
            --create-namespace \
            --values ${{ env.HELM_CHART_PATH }}/values.yaml \
            --values ${{ env.HELM_CHART_PATH }}/values.staging.yaml \
            --set image.tag="${{ steps.image-tag.outputs.IMAGE_TAG }}" \
            --set global.namespace=edusphere-staging \
            --atomic \
            --timeout 8m \
            --history-max 5 \
            --description "Staging deploy ${{ steps.image-tag.outputs.IMAGE_TAG }} by ${{ github.actor }}"
          echo "Helm staging upgrade completed successfully."

      # ── Wait for all deployments to roll out ──────────────────────────────
      - name: Wait for rollout — gateway
        run: |
          kubectl rollout status deployment/edusphere-staging-gateway \
            -n edusphere-staging --timeout=300s

      - name: Wait for rollout — subgraphs
        run: |
          for subgraph in core content annotation collaboration agent knowledge; do
            echo "Waiting for subgraph-${subgraph}..."
            kubectl rollout status \
              deployment/edusphere-staging-subgraph-${subgraph} \
              -n edusphere-staging --timeout=300s
          done

      - name: Wait for rollout — frontend
        run: |
          kubectl rollout status deployment/edusphere-staging-frontend \
            -n edusphere-staging --timeout=300s

      # ── Pod health verification ────────────────────────────────────────────
      - name: Verify pod health in staging
        run: |
          echo "=== Pod status ==="
          kubectl get pods -n edusphere-staging -o wide

          TOTAL=$(kubectl get pods -n edusphere-staging --no-headers | wc -l)
          RUNNING=$(kubectl get pods -n edusphere-staging \
            --field-selector=status.phase=Running --no-headers | wc -l)

          echo "Running: ${RUNNING} / ${TOTAL}"
          if [ "${RUNNING}" -lt "${TOTAL}" ]; then
            echo "ERROR: Not all pods are running."
            kubectl get pods -n edusphere-staging
            kubectl describe pods -n edusphere-staging \
              --field-selector=status.phase!=Running || true
            exit 1
          fi

      # ── Annotate deployment record ─────────────────────────────────────────
      - name: Annotate staging deployment
        run: |
          kubectl annotate deployment/edusphere-staging-gateway \
            kubernetes.io/change-cause="staging: ${{ steps.image-tag.outputs.IMAGE_TAG }} by ${{ github.actor }} at ${{ steps.image-tag.outputs.DEPLOY_TIME }}" \
            -n edusphere-staging --overwrite

      # ── Rollback on failure ────────────────────────────────────────────────
      - name: Rollback staging on failure
        if: failure() && steps.helm-staging.conclusion != 'skipped'
        run: |
          echo "Staging deploy failed — rolling back..."
          helm rollback edusphere-staging -n edusphere-staging || true
          kubectl rollout status deployment/edusphere-staging-gateway \
            -n edusphere-staging --timeout=300s || true
          echo "Rollback attempt complete."

      # ── Failure diagnostics ────────────────────────────────────────────────
      - name: Collect diagnostics on failure
        if: failure()
        run: |
          echo "=== Recent Events (staging) ==="
          kubectl get events -n edusphere-staging \
            --sort-by='.lastTimestamp' | tail -30 || true
          echo ""
          echo "=== Pod Logs — gateway ==="
          kubectl logs -l app.kubernetes.io/component=gateway \
            -n edusphere-staging --tail=50 || true

  # ─────────────────────────────────────────────────────────────────────────
  # JOB 2 — Smoke Tests against Staging
  # ─────────────────────────────────────────────────────────────────────────
  smoke-test-staging:
    name: Smoke Tests — Staging
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: deploy-staging
    if: |
      needs.deploy-staging.result == 'success' &&
      (github.event_name == 'push' || github.event.inputs.environment == 'staging')

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Make smoke-test script executable
        run: chmod +x ./scripts/smoke-test.sh

      - name: Run smoke tests against staging
        env:
          GATEWAY_URL: https://staging-api.edusphere.dev
          FRONTEND_URL: https://staging.edusphere.dev
          ENVIRONMENT: staging
        run: ./scripts/smoke-test.sh

      - name: Post smoke-test summary
        if: always()
        run: |
          echo "=== Staging Smoke Test Summary ==="
          echo "Image tag : ${{ needs.deploy-staging.outputs.image_tag }}"
          echo "Deploy time: ${{ needs.deploy-staging.outputs.deploy_time }}"
          echo "Run by    : ${{ github.actor }}"
          echo "Commit    : ${{ github.sha }}"

  # ─────────────────────────────────────────────────────────────────────────
  # JOB 3 — Deploy to Production
  # Manual approval gate enforced by the 'production' GitHub Environment.
  # Canary pattern: Helm deploys with rolling update strategy; traffic shifts
  # automatically as readiness probes pass on each new pod.
  # ─────────────────────────────────────────────────────────────────────────
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    timeout-minutes: 40
    environment:
      name: production
      url: https://api.edusphere.dev/graphql
    # Require staging smoke tests to pass first, unless emergency force flag.
    needs: [check-prerequisites, deploy-staging, smoke-test-staging]
    if: |
      needs.check-prerequisites.outputs.can_deploy == 'true' &&
      (
        (
          needs.smoke-test-staging.result == 'success' &&
          (
            github.event.inputs.environment == 'production' ||
            (github.event_name == 'push' && needs.deploy-staging.result == 'success')
          )
        ) ||
        (
          github.event.inputs.force_production == 'true' &&
          github.event.inputs.environment == 'production'
        )
      )

    outputs:
      image_tag: ${{ steps.image-tag-prod.outputs.IMAGE_TAG }}
      deploy_time: ${{ steps.image-tag-prod.outputs.DEPLOY_TIME }}
      previous_revision: ${{ steps.pre-deploy.outputs.PREVIOUS_REVISION }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # ── Tooling setup ──────────────────────────────────────────────────────
      - name: Set up kubectl ${{ env.KUBECTL_VERSION }}
        uses: azure/setup-kubectl@v4
        with:
          version: ${{ env.KUBECTL_VERSION }}

      - name: Set up Helm ${{ env.HELM_VERSION }}
        uses: azure/setup-helm@v4
        with:
          version: ${{ env.HELM_VERSION }}

      # ── Cluster authentication ─────────────────────────────────────────────
      - name: Configure kubectl for production cluster
        run: |
          mkdir -p ~/.kube
          echo "${{ secrets.KUBECONFIG_PRODUCTION }}" | base64 -d > ~/.kube/config
          chmod 600 ~/.kube/config
          kubectl config use-context production

      - name: Verify production cluster connection
        run: |
          echo "Cluster info:"
          kubectl cluster-info
          echo ""
          echo "Node status:"
          kubectl get nodes -o wide

      # ── Derive image tag ───────────────────────────────────────────────────
      - name: Derive image tag and deploy metadata
        id: image-tag-prod
        run: |
          SHORT_SHA="${GITHUB_SHA::7}"
          IMAGE_TAG="main-${SHORT_SHA}"
          DEPLOY_TIME="$(date -u +'%Y-%m-%dT%H:%M:%SZ')"
          echo "IMAGE_TAG=${IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "DEPLOY_TIME=${DEPLOY_TIME}" >> $GITHUB_OUTPUT
          echo "Deploying image tag: ${IMAGE_TAG}"

      # ── GHCR login ─────────────────────────────────────────────────────────
      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # ── Capture previous Helm revision for rollback reference ─────────────
      - name: Capture current Helm revision (pre-deploy)
        id: pre-deploy
        run: |
          REVISION=$(helm history edusphere-production -n edusphere-production \
            --max 1 --output json 2>/dev/null \
            | python3 -c "import sys,json; data=json.load(sys.stdin); print(data[0]['revision'])" \
            2>/dev/null || echo "0")
          echo "PREVIOUS_REVISION=${REVISION}" >> $GITHUB_OUTPUT
          echo "Previous Helm revision: ${REVISION}"

      # ── Snapshot current state for audit trail ─────────────────────────────
      - name: Snapshot pre-deployment state
        run: |
          kubectl get all -n edusphere-production -o yaml \
            > /tmp/pre-deploy-snapshot-$(date +%Y%m%d-%H%M%S).yaml || true
          echo "Pre-deployment snapshot captured."

      # ── Blue-green canary via rolling update (Helm atomic) ─────────────────
      # Kubernetes rolling update strategy (maxSurge/maxUnavailable in templates)
      # shifts traffic gradually: new pods become Ready → old pods terminate.
      # --atomic rolls back automatically if any readiness probe fails within
      # --timeout; we add an explicit rollback step for full audit visibility.
      # Effective canary weight sequence:
      #   ~10 % traffic → new pods while old pods still serving
      #   100 % traffic → once all old pods are terminated
      - name: Helm upgrade — production (rolling/atomic)
        id: helm-production
        run: |
          helm upgrade --install edusphere-production ${{ env.HELM_CHART_PATH }} \
            --namespace edusphere-production \
            --create-namespace \
            --values ${{ env.HELM_CHART_PATH }}/values.yaml \
            --values ${{ env.HELM_CHART_PATH }}/values.production.yaml \
            --set image.tag="${{ steps.image-tag-prod.outputs.IMAGE_TAG }}" \
            --set global.namespace=edusphere-production \
            --atomic \
            --timeout 15m \
            --history-max 10 \
            --cleanup-on-fail \
            --description "Production deploy ${{ steps.image-tag-prod.outputs.IMAGE_TAG }} by ${{ github.actor }}"
          echo "Helm production upgrade completed."

      # ── Wait for every deployment to finish rolling ───────────────────────
      - name: Wait for rollout — gateway (production)
        run: |
          kubectl rollout status deployment/edusphere-production-gateway \
            -n edusphere-production --timeout=600s

      - name: Wait for rollout — subgraphs (production)
        run: |
          for subgraph in core content annotation collaboration agent knowledge; do
            echo "Waiting for subgraph-${subgraph}..."
            kubectl rollout status \
              deployment/edusphere-production-subgraph-${subgraph} \
              -n edusphere-production --timeout=600s
          done

      - name: Wait for rollout — frontend (production)
        run: |
          kubectl rollout status deployment/edusphere-production-frontend \
            -n edusphere-production --timeout=600s

      # ── Comprehensive pod health check ────────────────────────────────────
      - name: Verify pod health in production
        run: |
          echo "=== Pod status ==="
          kubectl get pods -n edusphere-production -o wide

          TOTAL=$(kubectl get pods -n edusphere-production --no-headers | wc -l)
          RUNNING=$(kubectl get pods -n edusphere-production \
            --field-selector=status.phase=Running --no-headers | wc -l)

          echo "Running: ${RUNNING} / ${TOTAL}"
          if [ "${RUNNING}" -lt "${TOTAL}" ]; then
            echo "ERROR: Not all pods are running."
            kubectl describe pods -n edusphere-production \
              --field-selector=status.phase!=Running || true
            exit 1
          fi

          # Verify HPA targets are reachable
          kubectl get hpa -n edusphere-production || true

      # ── Annotate deployment record ─────────────────────────────────────────
      - name: Annotate production deployment
        run: |
          kubectl annotate deployment/edusphere-production-gateway \
            kubernetes.io/change-cause="production: ${{ steps.image-tag-prod.outputs.IMAGE_TAG }} by ${{ github.actor }} at ${{ steps.image-tag-prod.outputs.DEPLOY_TIME }}" \
            -n edusphere-production --overwrite

          # Immutable audit ConfigMap — tolerates already-exists error
          kubectl create configmap \
            "deploy-audit-${GITHUB_SHA::12}" \
            --from-literal=deployed_at="${{ steps.image-tag-prod.outputs.DEPLOY_TIME }}" \
            --from-literal=commit="${{ github.sha }}" \
            --from-literal=image_tag="${{ steps.image-tag-prod.outputs.IMAGE_TAG }}" \
            --from-literal=deployed_by="${{ github.actor }}" \
            --from-literal=workflow_run="${{ github.run_id }}" \
            -n edusphere-production || true

      # ── Explicit rollback on failure ──────────────────────────────────────
      # --atomic already triggers Helm's own rollback, but we add an explicit
      # step here to capture the event clearly in the workflow log.
      - name: Rollback production on failure
        if: failure() && steps.helm-production.conclusion != 'skipped'
        run: |
          echo "Production deploy failed — initiating explicit Helm rollback..."
          PREV="${{ steps.pre-deploy.outputs.PREVIOUS_REVISION }}"
          if [ "${PREV}" != "0" ]; then
            helm rollback edusphere-production "${PREV}" \
              -n edusphere-production --wait --timeout 10m || true
          else
            helm rollback edusphere-production \
              -n edusphere-production --wait --timeout 10m || true
          fi

          echo "Verifying rollback state..."
          kubectl rollout status deployment/edusphere-production-gateway \
            -n edusphere-production --timeout=300s || true

          echo "Rollback complete. Previous revision: ${PREV}"

      # ── Failure diagnostics ────────────────────────────────────────────────
      - name: Collect diagnostics on failure
        if: failure()
        run: |
          echo "=== Recent Events (production) ==="
          kubectl get events -n edusphere-production \
            --sort-by='.lastTimestamp' | tail -40 || true
          echo ""
          echo "=== Pod Logs — gateway ==="
          kubectl logs -l app.kubernetes.io/component=gateway \
            -n edusphere-production --tail=100 --prefix || true
          echo ""
          echo "=== Helm History ==="
          helm history edusphere-production -n edusphere-production \
            --max 5 || true

  # ─────────────────────────────────────────────────────────────────────────
  # JOB 4 — Post-Production Smoke Tests
  # ─────────────────────────────────────────────────────────────────────────
  smoke-test-production:
    name: Smoke Tests — Production
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: deploy-production
    if: needs.deploy-production.result == 'success'

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Make smoke-test script executable
        run: chmod +x ./scripts/smoke-test.sh

      # Wait 60 s for Traefik to route traffic to the new pods before testing.
      - name: Stabilisation wait (60 s)
        run: sleep 60

      - name: Run smoke tests against production
        env:
          GATEWAY_URL: https://api.edusphere.dev
          FRONTEND_URL: https://app.edusphere.io
          ENVIRONMENT: production
        run: ./scripts/smoke-test.sh

      - name: Post production smoke-test summary
        if: always()
        run: |
          echo "=== Production Smoke Test Summary ==="
          echo "Image tag : ${{ needs.deploy-production.outputs.image_tag }}"
          echo "Deploy time: ${{ needs.deploy-production.outputs.deploy_time }}"
          echo "Run by    : ${{ github.actor }}"
          echo "Commit    : ${{ github.sha }}"

      # Set up kubectl for emergency rollback if smoke tests fail
      - name: Set up kubectl for emergency rollback
        if: failure()
        uses: azure/setup-kubectl@v4
        with:
          version: ${{ env.KUBECTL_VERSION }}

      - name: Set up Helm for emergency rollback
        if: failure()
        uses: azure/setup-helm@v4
        with:
          version: ${{ env.HELM_VERSION }}

      - name: Execute rollback — production (smoke-test failure)
        if: failure()
        run: |
          mkdir -p ~/.kube
          echo "${{ secrets.KUBECONFIG_PRODUCTION }}" | base64 -d > ~/.kube/config
          chmod 600 ~/.kube/config
          kubectl config use-context production

          echo "Post-deploy smoke tests failed — initiating Helm rollback..."
          helm rollback edusphere-production -n edusphere-production \
            --wait --timeout 10m || true
          kubectl rollout status deployment/edusphere-production-gateway \
            -n edusphere-production --timeout=300s || true
          echo "Emergency rollback complete."

  # ─────────────────────────────────────────────────────────────────────────
  # JOB 5 — Manual Rollback (workflow_dispatch only)
  # Rolls back a specific environment to a given Helm revision.
  # Usage: Actions → CD pipeline → Run workflow → set environment + revision.
  # ─────────────────────────────────────────────────────────────────────────
  rollback:
    name: Manual Rollback — ${{ github.event.inputs.environment }}
    runs-on: ubuntu-latest
    timeout-minutes: 20
    # Only runs when explicitly dispatched with a rollback revision number.
    if: |
      github.event_name == 'workflow_dispatch' &&
      github.event.inputs.rollback_revision != ''

    steps:
      - name: Validate rollback inputs
        run: |
          ENV="${{ github.event.inputs.environment }}"
          REV="${{ github.event.inputs.rollback_revision }}"
          echo "Rolling back environment: ${ENV} to Helm revision: ${REV}"
          if ! [[ "${REV}" =~ ^[0-9]+$ ]]; then
            echo "ERROR: rollback_revision must be a positive integer. Got: '${REV}'"
            exit 1
          fi

      # ── Tooling setup ──────────────────────────────────────────────────────
      - name: Set up kubectl ${{ env.KUBECTL_VERSION }}
        uses: azure/setup-kubectl@v4
        with:
          version: ${{ env.KUBECTL_VERSION }}

      - name: Set up Helm ${{ env.HELM_VERSION }}
        uses: azure/setup-helm@v4
        with:
          version: ${{ env.HELM_VERSION }}

      # ── Cluster authentication — select secret by environment ──────────────
      - name: Configure kubectl — staging
        if: github.event.inputs.environment == 'staging'
        run: |
          mkdir -p ~/.kube
          echo "${{ secrets.KUBECONFIG_STAGING }}" | base64 -d > ~/.kube/config
          chmod 600 ~/.kube/config
          kubectl config use-context staging

      - name: Configure kubectl — production
        if: github.event.inputs.environment == 'production'
        run: |
          mkdir -p ~/.kube
          echo "${{ secrets.KUBECONFIG_PRODUCTION }}" | base64 -d > ~/.kube/config
          chmod 600 ~/.kube/config
          kubectl config use-context production

      # ── Show release history before rolling back ───────────────────────────
      - name: Show Helm release history
        run: |
          RELEASE="edusphere-${{ github.event.inputs.environment }}"
          NS="edusphere-${{ github.event.inputs.environment }}"
          echo "=== Helm release history for ${RELEASE} ==="
          helm history "${RELEASE}" -n "${NS}" --max 10 || true

      # ── Execute rollback ───────────────────────────────────────────────────
      - name: Helm rollback — ${{ github.event.inputs.environment }} to revision ${{ github.event.inputs.rollback_revision }}
        run: |
          RELEASE="edusphere-${{ github.event.inputs.environment }}"
          NS="edusphere-${{ github.event.inputs.environment }}"
          REV="${{ github.event.inputs.rollback_revision }}"

          helm rollback "${RELEASE}" "${REV}" \
            -n "${NS}" \
            --wait \
            --timeout 10m
          echo "Helm rollback to revision ${REV} initiated."

      # ── Verify rollout after rollback ──────────────────────────────────────
      - name: Wait for gateway rollout after rollback
        run: |
          ENV="${{ github.event.inputs.environment }}"
          kubectl rollout status \
            "deployment/edusphere-${ENV}-gateway" \
            -n "edusphere-${ENV}" --timeout=300s

      - name: Wait for subgraph rollouts after rollback
        run: |
          ENV="${{ github.event.inputs.environment }}"
          for subgraph in core content annotation collaboration agent knowledge; do
            kubectl rollout status \
              "deployment/edusphere-${ENV}-subgraph-${subgraph}" \
              -n "edusphere-${ENV}" --timeout=300s
          done

      - name: Verify pod health after rollback
        run: |
          ENV="${{ github.event.inputs.environment }}"
          NS="edusphere-${ENV}"
          echo "=== Pod status after rollback ==="
          kubectl get pods -n "${NS}" -o wide

          TOTAL=$(kubectl get pods -n "${NS}" --no-headers | wc -l)
          RUNNING=$(kubectl get pods -n "${NS}" \
            --field-selector=status.phase=Running --no-headers | wc -l)
          echo "Running: ${RUNNING} / ${TOTAL}"
          if [ "${RUNNING}" -lt "${TOTAL}" ]; then
            echo "WARNING: Not all pods Running after rollback."
            kubectl describe pods -n "${NS}" \
              --field-selector=status.phase!=Running || true
          fi

      - name: Rollback summary
        if: always()
        run: |
          echo "=== Rollback Summary ==="
          echo "Environment : ${{ github.event.inputs.environment }}"
          echo "Target rev  : ${{ github.event.inputs.rollback_revision }}"
          echo "Triggered by: ${{ github.actor }}"
          echo "Commit      : ${{ github.sha }}"
          echo "Run ID      : ${{ github.run_id }}"

  # ─────────────────────────────────────────────────────────────────────────
  # JOB 6 — Notify (always runs — reports final status)
  # ─────────────────────────────────────────────────────────────────────────
  notify:
    name: Deployment Notification
    runs-on: ubuntu-latest
    timeout-minutes: 5
    permissions:
      statuses: write
    needs:
      - check-prerequisites
      - deploy-staging
      - smoke-test-staging
      - deploy-production
      - smoke-test-production
    if: always()

    steps:
      - name: Determine overall deployment status
        id: status
        run: |
          STAGING="${{ needs.deploy-staging.result }}"
          SMOKE_STAGING="${{ needs.smoke-test-staging.result }}"
          PRODUCTION="${{ needs.deploy-production.result }}"
          SMOKE_PROD="${{ needs.smoke-test-production.result }}"

          if [ "${PRODUCTION}" == "success" ] && [ "${SMOKE_PROD}" == "success" ]; then
            OVERALL="success"
            ENV_LABEL="production + staging"
            EMOJI="[OK]"
          elif [ "${PRODUCTION}" == "failure" ] || [ "${SMOKE_PROD}" == "failure" ]; then
            OVERALL="failure"
            ENV_LABEL="production (FAILED)"
            EMOJI="[FAIL]"
          elif [ "${STAGING}" == "success" ] && [ "${SMOKE_STAGING}" == "success" ]; then
            OVERALL="success"
            ENV_LABEL="staging"
            EMOJI="[OK]"
          elif [ "${STAGING}" == "failure" ] || [ "${SMOKE_STAGING}" == "failure" ]; then
            OVERALL="failure"
            ENV_LABEL="staging (FAILED)"
            EMOJI="[FAIL]"
          else
            OVERALL="skipped"
            ENV_LABEL="(no environments deployed)"
            EMOJI="[SKIP]"
          fi

          echo "OVERALL=${OVERALL}" >> $GITHUB_OUTPUT
          echo "ENV_LABEL=${ENV_LABEL}" >> $GITHUB_OUTPUT
          echo "EMOJI=${EMOJI}" >> $GITHUB_OUTPUT
          echo "Deployment status: ${EMOJI} ${ENV_LABEL}"

      # Post a GitHub commit status check
      - name: Post GitHub deployment status
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const overall        = '${{ steps.status.outputs.OVERALL }}';
            const envLabel       = '${{ steps.status.outputs.ENV_LABEL }}';
            const emoji          = '${{ steps.status.outputs.EMOJI }}';
            const sha            = '${{ github.sha }}';
            const actor          = '${{ github.actor }}';
            const runId          = '${{ github.run_id }}';
            const runUrl         = `https://github.com/${{ github.repository }}/actions/runs/${runId}`;
            const shortSha       = sha.substring(0, 7);
            const stagingResult  = '${{ needs.deploy-staging.result }}';
            const smokeStaging   = '${{ needs.smoke-test-staging.result }}';
            const prodResult     = '${{ needs.deploy-production.result }}';
            const smokeProd      = '${{ needs.smoke-test-production.result }}';

            const statusEmoji = (r) =>
              r === 'success' ? '[OK]' : r === 'skipped' ? '[SKIP]' : '[FAIL]';

            const body = [
              `## ${emoji} CD Pipeline — ${envLabel}`,
              '',
              `| Field         | Value |`,
              `|---------------|-------|`,
              `| Commit        | \`${shortSha}\` |`,
              `| Deployed by   | @${actor} |`,
              `| Workflow run  | [#${runId}](${runUrl}) |`,
              '',
              `### Job Results`,
              `| Job | Result |`,
              `|-----|--------|`,
              `| Build & Push Images      | ${statusEmoji('${{ needs.build-and-push.result }}')} \`${{ needs.build-and-push.result }}\` |`,
              `| Deploy Staging           | ${statusEmoji(stagingResult)} \`${stagingResult}\` |`,
              `| Smoke Tests Staging      | ${statusEmoji(smokeStaging)} \`${smokeStaging}\` |`,
              `| Deploy Production        | ${statusEmoji(prodResult)} \`${prodResult}\` |`,
              `| Smoke Tests Production   | ${statusEmoji(smokeProd)} \`${smokeProd}\` |`,
              '',
              `### Endpoints`,
              `- **Staging API:** https://staging-api.edusphere.dev/graphql`,
              `- **Staging UI:**  https://staging.edusphere.dev`,
              `- **Production API:** https://api.edusphere.dev/graphql`,
              `- **Production UI:**  https://app.edusphere.io`,
            ].join('\n');

            await github.rest.repos.createCommitStatus({
              owner:       context.repo.owner,
              repo:        context.repo.repo,
              sha:         sha,
              state:       overall === 'success' ? 'success' : overall === 'skipped' ? 'pending' : 'failure',
              context:     'CD / Deployment',
              description: `${envLabel} — ${overall}`,
              target_url:  runUrl,
            });

            console.log(body);

      # Slack notification (opt-in: only when SLACK_NOTIFICATIONS_ENABLED=true)
      - name: Notify Slack
        if: vars.SLACK_NOTIFICATIONS_ENABLED == 'true'
        uses: slackapi/slack-github-action@v1.26.0
        with:
          payload: |
            {
              "text": "${{ steps.status.outputs.EMOJI }} *EduSphere CD* — ${{ steps.status.outputs.ENV_LABEL }}",
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "${{ steps.status.outputs.EMOJI }} *EduSphere Deployment* — `${{ steps.status.outputs.ENV_LABEL }}`\n*Commit:* `${{ github.sha }}`\n*Actor:* ${{ github.actor }}\n*Run:* <https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}|#${{ github.run_id }}>"
                  }
                },
                {
                  "type": "section",
                  "fields": [
                    { "type": "mrkdwn", "text": "*Deploy Staging:*\n${{ needs.deploy-staging.result }}" },
                    { "type": "mrkdwn", "text": "*Smoke Staging:*\n${{ needs.smoke-test-staging.result }}" },
                    { "type": "mrkdwn", "text": "*Deploy Production:*\n${{ needs.deploy-production.result }}" },
                    { "type": "mrkdwn", "text": "*Smoke Production:*\n${{ needs.smoke-test-production.result }}" }
                  ]
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          SLACK_WEBHOOK_TYPE: INCOMING_WEBHOOK
